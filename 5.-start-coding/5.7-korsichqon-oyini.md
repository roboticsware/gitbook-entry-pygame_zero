# 5.7 Ko'rsichqon oyini yasash - Keng qamrovli

Va nihoyat, sizni ushbu kitobning soâ€˜nggi misoliga yetib kelganingiz bilan sizni tabriklayman. Oldingi misollarni muvaffaqiyatli oâ€˜zlashtirib, shu bosqichga yetib kelganingizda, Python kodlashning zavqini ham asta-sekin his qila boshlagan boâ€˜lsangiz kerak. Kutilganidan koâ€˜ra matnli kodlash juda qiyin yoki zerikarli boâ€˜lmaganiga ishonaman. Agar shunday bo'lsa, siz bu kitobning asosiy maqsadi boâ€˜lgan matnli kodlash olamiga kirish vazifasini toâ€˜liq bajarganingizni hisoblasangiz boâ€˜ladi.

Soâ€˜nggi misol hozirgacha boâ€˜lgan misollarning umumiy koâ€˜rinishi boâ€˜lib, oldingilariga qaraganda biroz murakkabroq. Ammo, vaqt ajratib, bosqichma-bosqich tushunib borsangiz, buni ham uddalaysiz.

{% code lineNumbers="true" %}
```python
from pgzhelper import *
import random

WIDTH = 960
HEIGHT = 540

bolga = Actor('toy_hammer', (WIDTH / 2, HEIGHT / 2))
bolga.scale = 0.5
bolga.angle = 40

hisob = 0
hammer_pressed = False

GAP_FROM_SCR = 50
korsichqonlar = []
for _ in range(6):
    korsichqon = Actor('mole')
    korsichqon.anchor = ('left', 'top')
    x = random.randint(GAP_FROM_SCR, WIDTH - korsichqon.width + GAP_FROM_SCR)
    y = random.randint(GAP_FROM_SCR, HEIGHT - korsichqon.height + GAP_FROM_SCR)
    korsichqon.pos = (x, y)
    korsichqon.scale = 0.5
    korsichqon.visible = False
    korsichqonlar.append(korsichqon)


def draw():
    global korsichqon
    screen.blit('field', (0, 0))

    for korsichqon in korsichqonlar:
        if korsichqon.visible: 
            korsichqon.draw()
        if hammer_pressed and korsichqon.visible and korsichqon.collide_pixel(bolga):
            sounds.toi.play()
            korsichqonlar.remove(korsichqon)
            score += 1

    hammer.draw()
    screen.draw.text('Hisob: ' + str(hisob), (20, 20), color='black')


def update():
    if random.randint(0, 10) == 0:
        if len(korsichqonlar) != 0:
            mole_list = random.sample(korsichqonlar, 1)
            mole_list[0].visible = not mole_list[0].visible
        else:
            game.exit()


def on_mouse_move(pos):
    bolga.centerx, bolga.centery = pos


def on_mouse_down():
    global hammer_pressed
    hammer_pressed = True
    animate(hammer, angle=75, tween='accelerate', duration=0.1, on_finished=animation_done)
    

def animation_done():
    global hammer_pressed
    animate(hammer, angle=40, tween='accelerate', duration=0.1)
    hammer_pressed = False
```
{% endcode %}

ğŸ”¢ Entry versiyasidagi qoâ€˜ziqorinlarni tutish oâ€˜yinidan farqli jihati shundaki, Entry versiyasida qoâ€˜ziqorinlarning joylashuvi oâ€˜zgarmas, lekin Pygame Zero versiyasida ko'rsichqonlar boshlangâ€˜ich holatda tasodifiy (random) tarzda joylashtiriladi. Avval tasodifiylikdan foydalanish uchun alohida tashqi modul, ya'ni random moduli kerak boâ€˜ladi, shuning uchun 2-qatorda ushbu modul import qilinmoqda. 14-24-qatorlardagi kodlar ekranda tasodifiy joylashishi kerak boâ€˜lgan jami 6 ta qoâ€˜ziqorin Actor obyektlarini yaratib, bu yaratilgan 6 tasini moles (qoâ€˜ziqorinlar) degan roâ€˜yxatga joylashtirib ishlatadi.

19-20-qatorlarda foydalanilgan randint metodini Entryda foydalanilgan "tasodifiy son" bloki bilan solishtirsak, katta farqi yoâ€˜q. U tasodifiy son tanlash uchun diapazonning eng kichik va eng katta qiymatlarini argument sifatida qabul qiladi. Lekin, metod nomida int (integer, butun son) boâ€˜lganligi sababli, u faqat butun sonlar diapazonida tanlov qilishi mumkin. Agar suzuvchi nuqta (float) qiymatlari kerak boâ€˜lsa, randfloat metodidan foydalanish mumkin.

randint metodiga yuborilayotgan eng kichik va eng katta qiymatlar uchun GAP\_FROM\_SCR deb nomlangan 50 piksellik boâ€˜shliq (margin) qiymati ishlatilmoqda. Maqsad shuki, tasodifiy joylashuv paytida oâ€˜yin ekrani chetiga juda yaqin joylashib qolmasligi uchun, ko'rsichqonlar tasvirlari ekran chetida chiqib ketmasligi va qirqilib qolmasligi uchun ekrandan 50 piksellik ichkariga kirib tasodifiy qiymatlarni aniqlash kerak.

23-qatordagi "visible" (koâ€˜rinuvchan) deb nomlangan yangi obyekt xususiyati ishlatilmoqda, bu Actor (aktyor) obyektida mavjud boâ€˜lmagan ichki xususiyat. Biz oâ€˜yinda kerak boâ€˜lganimiz uchun qoâ€˜ziqorinlar ekranda koâ€˜rinishi yoki koâ€˜rinmasligini aniqlash uchun bu xususiyatni qoâ€˜shimcha qilib oldik. Shu kabi siz ham kerak boâ€˜lsa, mavjud obyektlarga oâ€˜z xususiyatlaringizni qoâ€˜shishingiz mumkin. Maqsad, ko'rsichqonlar oâ€˜yinida qoâ€˜ziqorinlar koâ€˜rinib yoki koâ€˜rinmasligini farqlash, bu oâ€˜tgan bobda koâ€˜rsatilgan flag (bayroq) oâ€˜zgaruvchisi kabi ishlaydi.

ğŸ”¢ Oâ€˜yinni qiziqarli qilish uchun tasodifiy ko'sichqonning koâ€˜rinishi yoki koâ€˜rinmasligi ham tasodifiy boâ€˜lishi kerak. Buni amalga oshiruvchi kod update funksiyasida 44-47-qatorlarda joylashgan. Biz oâ€˜yinda ishlatiladigan obyektlarning joylashuvi, holati va boshqa ma'lumotlarini yangilab turadigan update (yangilash) funksiyasi juda tez-tez chaqirilishini bilamiz, lekin qancha tez-tezligini yaxshi bilmasdik. Endi nihoyat, bu tezlik haqida gapirishimiz kerak, bu soniyada 60 kadr (60FPS) tezlikda amalga oshiriladi. Bu juda tez tezlikda, soniyasiga 60 marta chaqiriladi. Masala shundaki, 60FPS tezligi biz uchun juda tez, bizga juda tez yoki juda sekin boâ€˜lmagan holda oâ€˜yin qiziqarli boâ€˜lishi uchun tirik qolgan ko'rsichqonlar orasidan tasodifiy tarzda koâ€˜rinish/koâ€˜rinmasligini aniqlash kerak. Ushbu tezlik (0-10 oraligâ€˜idagi qiymatlarda 0 tanlanganida) 44-qatorda amalga oshirilgan. Tirik qolgan ko'rsichqonlardan birini tasodifiy tanlash random.sample metodi yordamida 45-46-qatorlarda amalga oshirildi va 47-qatorda tanlangan ko'rsichqonning koâ€˜rinish xususiyatini oâ€˜zgartirish orqali koâ€˜rinish yoki koâ€˜rinmasligi boshqariladi.

ğŸ”¢ Endi qolgan kodning katta qismi rezina bolgâ€˜aning animatsiyasi bilan bogâ€˜liq. Oldingi misolda animatsiya bitta Actor (aktyor) ichidagi bir nechta tasvirlarning aylanishi orqali amalga oshirilgan boâ€˜lsa, bu safargi animatsiya hozirgi joylashuvdan ma'lum bir joyga yoki burchakka belgilangan vaqt ichida harakatlanish animatsiyasidir. Rezina bolgâ€˜a sichqoncha bosilgan paytda zarba berish harakatini bajarish uchun oldinga 75 daraja burchak bilan tezda egilib, keyin esa hozirgi burchak (40 daraja) holatiga tezda qaytishi kerak. 59-qatordagi animate (animatsiya) metodidan birinchi marta foydalanilmoqda va jami 5 ta argument ishlatilgan. Xullas, qaysi obyekt (bu yerda hammer) va qaysi xususiyat (bu yerda angle) qancha vaqt ichida (bu yerda 0.1 soniya) qanday turdagi animatsiya boâ€˜lishi kerak (bu yerda accelerate) ekanligini belgilaydi. "Accelerate" (tezlashish) turidagi animatsiya vaqt oâ€˜tishi bilan tezlashayotgan harakatni tasvirlaydi. Ushbu animatsiyaning jami 10 xil turi mavjud boâ€˜lib, ularning har birini kutubxona qoâ€˜llanmasi orqali koâ€˜rish mumkin. Argumentlar orasidagi soâ€˜nggi qiymat boâ€˜lgan on\_finished parametri ham qiziq boâ€˜lishi mumkin. Bu yerda 62-qatorda aniqlangan "animation\_done" nomli funksiyani chaqiryapmiz. Xuddi parametrlardan koâ€˜rinib turganidek, animatsiya tugagan paytda koâ€˜rsatilgan funksiyani chaqirishga imkon beradi. Bizning maqsadimiz rezina bolgâ€˜aning oldinga egilish animatsiyasi tugashi bilan hozirgi joylashuviga tezda qaytarish animatsiyasini bajarishdir.

ğŸ”¢ Foydalanuvchi ko'rsichqonni qachon urganligini qanday aniqlashimiz mumkin? 34-qatorda bu savolga javob mavjud. 3 ta shart bir vaqtda bajarilishi kerak. Rezina bolgâ€˜aning animatsiyasi oldinga egilib turgan boâ€˜lishi kerak (ya'ni bolgâ€˜a koâ€˜tarilayotgan paytda emas), ko'rsichqon yashirin holatda emas, balki ekranda koâ€˜rinib turishi kerak, va oxirgi shart, bolgâ€˜a va ko'rsichqon oâ€˜rtasida toâ€˜qnashuv tekshiruvi muvaffaqiyatli oâ€˜tishi kerak. Ushbu 3 ta shart bajarilganda ko'rsichqon urilgan hisoblanadi. Muvaffaqiyatli zarbadan soâ€˜ng effektli ovoz chiqadi (35-qator), urilgan ko'rsichqon moles (ko'rsichqonlar) roâ€˜yxatidan oâ€˜chirib tashlanadi (36-qator) va oxirgi bosqichda oâ€˜yinda toâ€˜plangan ochkolar hisoblanadi (37-qator).

Shu bilan ko'rsichqon oâ€˜yinining barcha kodlari haqida tushuntirish yakunlandi va oxirgi bosqichda oâ€˜yin natijasini koâ€˜rish bilan tugatamiz.

<figure><img src="../.gitbook/assets/image (1).gif" alt=""><figcaption></figcaption></figure>

Ushbu kitobni shu misolgacha tugatganlarni yana bir bor tabriklayman. Bu bilan siz nihoyat Pygame Zero boshlang'ich darajasidan o'tdingiz. Shunday qilib, endi siz Pygame Zero-ning yanada ilg'or darajasiga o'tishga tayyorsiz. Kitobning keyingi darajasida siz Python kodlash ko'nikmalaringizni biz hozirgacha ko'rgan misollardan farq qiladigan va o'yinga o'xshash(?) o'yinlar yaratish orqali yanada qiziqarli tarzda rivojlantirasiz. Siz hayajonlana boshladingizmi? Matnli dasturlash bo'yicha birinchi sayohatingizda sizga hamroh bo'lganimdan xursand bo'ldim va muallif sizning sayohatingizda sizni xursand qilishda davom etadi. Bundan tashqari, men kodlash sayohatingizda sizga amaliy yordam beradigan va o'rganishingizga yordam beradigan kodlash vositalari va kitoblarni tayyorlashni davom etaman. Va nihoyat, agar sizda tushunarsiz misollar haqida savollaringiz yoki qo'shimcha fikrlaringiz bo'lsa, iltimos, onlayn hamjamiyat orqali bog'laning. Sizning sayohatingiz hech qachon yolg'iz emas!

â˜€ï¸ Muallif tomonidan 2024 yilning jazirama yozi oxirida chop etilgan â˜€ï¸
